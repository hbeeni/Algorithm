# 에라토스테네스의 체

> 소수를 구하는 알고리즘

1. 구하고자 하는 소수의 범위만큼 1차원 배열을 생성한다.
2. 2부터 시작하고 현재 숫자가 지워지지 않을 때는 현재 선택된 숫자의 배수에 해당하는 수를 배열에서 끝까지 탐색하면서 지운다. 이 때 처음으로 선택된 숫자는 지우지 않는다.
3. 배열의 끝까지 2를 반복한 후 배열에서 남아 있는 모든 숫자를 출력한다.

- 이중 for문을 사용하므로 시간 복잡도가 O(N<sup>2</sup>) 정도라고 판단할 수 있지만 실제로는 O(Nlog(logN)) 정도이다. 배수를 삭제하는 연산으로 실제 구현에서 바깥쪽 for문을 생략하는
  경우가 빈번하게 발생하기 때문이다.

# 오일러 피

> 서로소의 개수를 구하는 알고리즘

## 정의

오일러 피 함수 P[N]:  1부터 N까지 범위에서 N과 서로소인 자연수의 개수

## 원리

1. 구하고자 하는 오일러 피의 범위만큼 배열을 초기화한다.
2. 2부터 시작해 현재 배열의 값과 인덱스가 같으면(= 소수이면) 현재 선택된 숫자(K)의 배수에 해당하는 수를 배열 끝까지 탐색하며 P[i] = P[i] - (P[i] / K) 연산을 수행한다. (i는 K의
   배수)
3. 배열의 끝까지 2를 반복하여 오릴러 피 함수를 완성한다.

## 수학적으로 이해하기

- 초기 상태: P[6] = 6 -> 서로소가 될 수 있는 후보의 개수로 초기화(1, 2, 3, 4, 5, 6)
- 2의 배수로 인한 후보 탈락 -> P[6] = 6 - (6 / 2) = 3(1, 3, 5)
- 3의 배수로 인한 후보 탈락 -> P[6] = 3 - (3 / 3) = 2(1, 5)

이 때 후보를 삭제하는 기준을 업데이트 된 3으로 진행하는 이유는 3의 배수 중 2의 배수인 수들은, 즉 3과 2의 공배수는 2의 배수에서 이미 삭제됐기 때문에 중복 삭제를 막기 위함이다.
최종적으로 P[6] = 2가 된다. 이 때 2의 의미는 6이 6 이하의 숫자들 중 서로소가 되는 개수가 2개(1, 5)라는 뜻이다.

# 유클리드 호제법

> 두 수의 최대 공약수를 구하는 알고리즘

1. 큰 수를 작은 수로 나누는 MOD 연산을 수행한다.
2. 앞 단계에서의 작은 수와 MOD 연산 결괏값(나머지)으로 MOD 연산을 수행한다.
3. 나머지가 0이 되는 순간의 작은 수를 최대 공약수로 선택한다.

# 확장 유클리드 호제법

> 방정식의 해를 구하는 알고리즘

$$ax + by = c$$

이 때 위 방정식은 c % gcd(a, b)인 경우에만 정수해를 가진다. 즉, c가 a와 b의 최대 공약수의 배수인 경우에만 정수해를 가진다.
이는 ax + by = c가 정수해를 갖게 하는 c의 최솟값이 gcd(a, b)라는 것을 의미한다.

5x + 9y = 2일 때 이 식을 만족하는 x, y를 구해보자.

1. 5x + 9y가 정수해를 갖게 하는 c의 최솟값이 gcd(5, 9)라는 것을 적용하여 식을 다시 놓는다. gcd(5, 9) = 1이므로 5x + 9y = 1로 식을 다시 놓고 다음으로 진행한다.
2. a, b로 유클리드 호제법을 반복 실행하여 몫, 나머지를 저장한다. 반복은 나머지가 0이 되면 중단한다.
3. 반복으로 구한 나머지와 몫을 이용하여 거꾸로 올라가며 x = y', y = x' - y' * q를 계산한다. x', y'는 각각 이전 x, 이전 y를 의미하고, q는 현재 보고 있는 몫을 의미한다. 이
   때 처음
   시작하는 x, y는 이전 x, 이전 y가 없으므로 각각 1, 0으로 지정하여 역계산을 지정한다.
4. 재귀 방식으로 알아낸 최종 x, y는 ax + by = gcd(a, b)를 만족한다. 그리고 c / gcd(a, b) = K를 가정하면 최초 방정식의 해는 Kx, Ky로 간단히 구할 수 있다. 3에서
   찾은 x는 2, y는 -1이므로 2 / 1 = 2이며, 2 * 2, 2 * -1에 의해 최초 방정식의 해는 4, -2가 된다.
