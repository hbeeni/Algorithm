### 버블 정렬

- 데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬
- O(n<sup>2</sup>)

### 선택(selection) 정렬

- 대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬
- O(n<sup>2</sup>)

### 삽입(insertion) 정렬

- 대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬
- 선택 데이터를 현재 정렬되니 데이터 범위 내에서 적절한 위치에 삽입하는 것이 핵심
- O(n<sup>2</sup>)

### 퀵 정렬

- pivot 값(기준값)을 선정해 해당 값을 기준으로 정렬
- pivot보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해서 정렬
- pivot을 중심으로 계속 데이터를 2개의 집합으로 나누면서 정렬하는 것이 핵심
- pivot이 어떻게 선정되는 지가 시간 복잡도에 많은 영향을 미침
- 데이터가 대부분 정렬되어 있는 경우 앞쪽에 있는 수를 pivot으로 선택하면 불필요한 연산이 많아짐 -> 중간 위치를 pivot으로 선정
- O(nlogn)

### ⭐️ 병합(merge) 정렬

- 이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬
- 분할 정복(divide and conquer) 방식을 사용해 데이터를 분할하고, 분할한 집합을 정렬하며 합침
- 2개의 그룹을 병합하는 과정은 꼭 숙지해야 함! (여러 문제에서 응용 가능)
- O(nlogn)

### 기수(radix) 정렬

- 시간 복잡도가 가장 짧은 정렬
- 값을 비교하지 않고, 데이터의 자릿수를 바탕으로 비교해 데이터를 정렬
- 값을 놓고 비교할 자릿수를 정한 다음 해당 자릿수만 비교
- ex) 234, 123 비교: 4-3 비교(1의 자리), 3-2 비교(10의 자리), 2-1 비교(100의 자리)
- O(kn), k = 데이터의 자릿수
